# Casos de teste: _Resets_ apÃ³s o _logout_ e novo _login_

HÃ¡ trÃªs outros cenÃ¡rios que tambÃ©m podem ser interessantes de testar, todos relacionados ao _logout_ e um novo _login_. SÃ£o eles:

- Que o campo de digitaÃ§Ã£o de um comando do Cypress Ã© limpo apÃ³s um _logout_  seguido de um novo _login_
- Que o botÃ£o _Run_ Ã© desabilitado apÃ³s a digitaÃ§Ã£o de um comando do Cypress, o _logout_ e um novo _login_
- Que o campo de _output_ da simulaÃ§Ã£o de um comando do Cypress Ã© limpo apÃ³s a execuÃ§Ã£o de um comando do Cypress, o _logout_ e um novo _login_

## ExercÃ­cio 1 ğŸ¯

Implemente o primeiro teste descrito acima, garantindo que tal funcionalidade atende Ã s expectativas dos/as usuÃ¡rios/as, garantindo que mesmo que o usuÃ¡rio tenha digitado um comando para execuÃ§Ã£o sem o executÃ¡-lo, ao fazer o _logout_ seguido de um novo _login_, o campo Ã© limpo

> ğŸ§‘â€ğŸ« Aqui vai uma sugestÃ£o de descriÃ§Ã£o para o caso de teste: `it clears the code input when logging off then logging in again`.

## ExercÃ­cio 2 ğŸ¯

Implemente o segundo teste descrito acima, garantindo que tal funcionalidade atende Ã s expectativas dos/as usuÃ¡rios/as, garantindo que mesmo que o usuÃ¡rio tenha digitado um comando para execuÃ§Ã£o sem o executÃ¡-lo, ao fazer o _logout_ seguido de um novo _login_, o botÃ£o _Run_ volta no estado desabilitado.

> ğŸ§‘â€ğŸ« Aqui vai uma sugestÃ£o de descriÃ§Ã£o para o caso de teste: `it disables the run button when logging off then logging in again`.

## ExercÃ­cio 3 ğŸ¯

Implemente o terceiro teste descrito acima, garantindo que tal funcionalidade atende Ã s expectativas dos/as usuÃ¡rios/as, garantindo que mesmo que o usuÃ¡rio tenha executado a simulaÃ§Ã£o de um comando, ao fazer o _logout_ seguido de um novo _login_, o _output_ da execuÃ§Ã£o Ã© limpo.

> ğŸ§‘â€ğŸ« Aqui vai uma sugestÃ£o de descriÃ§Ã£o para o caso de teste: `it clears the code output when logging off then logging in again`.

___

ParabÃ©ns! ğŸ‰ Vamos para a [liÃ§Ã£o 15](./15.md) para dar continuidade com os prÃ³ximos testes.
